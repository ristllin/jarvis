---
description: JARVIS project architecture, directory structure, and key conventions
globs: **/*.py,**/*.tsx,**/*.ts
alwaysApply: true
---

# JARVIS Architecture

## Project Structure
- `jarvis/` — canonical Python source (synced to `backend/jarvis/` for Docker builds via `build.sh`)
- `backend/jarvis/` — Docker build context (mirror of `jarvis/`)
- `frontend/src/` — React 18 + TypeScript + TailwindCSS dashboard
- `data/` — runtime persistent volume (DB, ChromaDB, blob, skills)

## Build & Deploy
- `build.sh` syncs `jarvis/` → `backend/jarvis/`, then `docker compose build` + `up`
- `build.sh --sync-only` for code sync without rebuild
- **Compose has no build config** — uses `image: jarvis:latest`. To rebuild: `docker build -t jarvis:latest -f Dockerfile .`
- Always edit `backend/jarvis/` then `rsync -a backend/jarvis/ jarvis/` (reverse sync) or edit both

## Code Sync Chain (CRITICAL — follow before finishing any change)
1. **Source of truth**: `backend/jarvis/` (what Dockerfile copies)
2. **build.sh** syncs `jarvis/` → `backend/jarvis/` before build (jarvis can be stale)
3. **Docker image** = `COPY backend/ .` — must rebuild to pick up changes
4. **Host `data/code/`** = bind-mounted to `/data` — entrypoint restores this → `/app/` on boot
5. **On image update**: entrypoint rsyncs image `/app/` → `data/code/` (image wins)
6. **Git**: Commit both `jarvis/` and `backend/jarvis/` changes. Push to remote.
7. **After deploy**: Run `self_analysis check=functional` and verify tools via `/api/tool-status`

## Core Loop
```
CoreLoop.run() → infinite loop:
  1. Load state + increment iteration
  2. Get budget status
  3. Plan (tier-1 LLM with system prompt + iteration context)
  4. Execute actions via ToolRegistry
  5. Store results → vector memory + working memory
  6. Deliver chat replies
  7. Update goals + short-term memories
  8. Periodic maintenance (every 10 iterations)
  9. Sleep (interruptible)
```

## Key Patterns
- **Dual-write**: Code changes go to both `/app/` (live) and `/data/code/` (persistent)
- **Tier routing**: Planner always level1, actions get per-action tiers
- **Skills**: Markdown files in `/data/skills/`, loaded by coding_agent and code_architect
- **Chat flow**: Web/Telegram/Email → `enqueue_chat()` → CoreLoop → plan → reply
- **Tools**: Inherit from `Tool` base class, register in `registry.py`

## Config
- `config.py` uses pydantic_settings, env vars auto-loaded
- Add new settings as class attributes with defaults

## Python Style
- Always async/await for I/O
- Structured logging: `log.info("event", key=value)`
- Tools return `ToolResult(success=bool, output=str, error=str|None)`
- Type hints on all signatures
- Imports: stdlib → third-party → local
